
          (* Result.bind *)
          (* (unify [ (ty1, ty2) ]) *)
          (* (fun sub1 -> *)
          (*   let row1, row2 = (subs sub1 row1, subs sub1 row2) in *)
          (*   Result.bind *)
          (*     (unify [ (row1, row2) ]) *)
          (*     (fun sub2 -> *)
          (*       if *)
          (*         MetaS.is_empty *)
          (*           (find_free (sub1 |> List.map fst |> MetaS.of_list) row1) *)
          (*       then *)
          (*         Result.map *)
          (*           (fun sub3 -> sub1 @ sub2 @ sub3) *)
          (*           (unify constraints) *)
          (*       else Error "")) *)



      (* | ( TRowExtension *)
      (*       { label = label1; field = ty1; row_extension = TEmptyRow }, *)
      (* TRowExtension { label = label2; field = ty2; row_extension = row2 } ) *)
      (* | ( TRowExtension { label = label2; field = ty2; row_extension = row2 }, *)
      (*     TRowExtension *)
      (*       { label = label1; field = ty1; row_extension = TEmptyRow } ) -> *)
      (*     (if label1 = label2 then *)
      (*        (ty1, ty2) :: (TEmptyRow, row2) :: constraints *)
      (*      else (t1, row2) :: constraints) *)
      (*     |> unify *)



      | ( TRowExtension
            { label = label1; field = ty1; row_extension = TEmptyRow },
          TRowExtension
            { label = label2; field = ty2; row_extension = TEmptyRow } ) ->
          if label1 = label2 then (ty1, ty2) :: constraints |> unify
          else
            Error
              ("could not unify two rows " ^ type_to_string t1 ^ " and "
             ^ type_to_string t2)
